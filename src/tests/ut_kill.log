DBG :Initializing Silk engine...
DBG :send msg={code=1, id=0, ctx=(nil)}
DBG :send msg={code=1, id=1, ctx=(nil)}
DBG :send msg={code=1, id=1, ctx=(nil)}
DBG :send msg={code=1, id=2, ctx=(nil)}
DBG :send msg={code=1, id=2, ctx=(nil)}
DBG :send msg={code=1, id=3, ctx=(nil)}
DBG :send msg={code=1, id=3, ctx=(nil)}
DBG :waiting for all BOOT msgs to be processed
DBG :waiting for all BOOT msgs to be processed
INFO:Thread starting. id=3078269760
DBG :Silk#0 booting...
DBG :recv msg={code=1, id=0, ctx=(nil)}
DBG :Silk#0 processing BOOT msg
DBG :recv msg={code=1, id=1, ctx=(nil)}
DBG :switching from Silk#0 to Silk#1
DBG :Silk#1 booting...
DBG :recv msg={code=1, id=1, ctx=(nil)}
DBG :Silk#1 processing BOOT msg
DBG :recv msg={code=1, id=2, ctx=(nil)}
DBG :switching from Silk#1 to Silk#2
DBG :Silk#2 booting...
DBG :recv msg={code=1, id=2, ctx=(nil)}
DBG :Silk#2 processing BOOT msg
DBG :recv msg={code=1, id=3, ctx=(nil)}
DBG :switching from Silk#2 to Silk#3
DBG :Silk#3 booting...
DBG :recv msg={code=1, id=3, ctx=(nil)}
DBG :Silk#3 processing BOOT msg
ut_kill__idle_cb
DBG :All Silks completed booting !
DBG :Silk initialization returns:0
Test Case 1
DBG :allocated Silk#0. still 3 available
DBG :allocated silk No 0
DBG :killing Silk#0
DBG :silk 0 recycled into free list
Test Case 2
DBG :allocated Silk#0. still 3 available
DBG :allocated silk No 0
DBG :dispatching Silk#0
DBG :send msg={code=2, id=0, ctx=(nil)}
DBG :dispatched silk#0 to do busy-wait
DBG :waiting for the silk to enter busy-wait
DBG :recv msg={code=2, id=0, ctx=(nil)}
DBG :switching from Silk#3 to Silk#0
DBG :switched into Silk#0
INFO:state= 2
INFO:silk 0 starting
DBG :ut_kill__main: Silk#0 starts... (oper=0)
DBG :looping indefenitely doing busy wait, waiting for exit signal
DBG :requesting silk#0 to exit
DBG :wait for the silk to become free
DBG :breaking out of busy-wait
DBG :ut_kill__main: Silk#0 ends!!!
INFO:silk 0 ended
ut_kill__idle_cb
DBG :killing Silk#0
DBG :silk 0 is in state 1 - no point killing it.
Test Case 3
DBG :allocated Silk#0. still 3 available
DBG :allocated silk No 0
DBG :dispatching Silk#0
DBG :send msg={code=2, id=0, ctx=(nil)}
DBG :dispatched silk#0 to wait for kill
DBG :waiting for the silk to enter busy-wait
DBG :recv msg={code=2, id=0, ctx=(nil)}
INFO:state= 2
INFO:silk 0 starting
DBG :ut_kill__main: Silk#0 starts... (oper=1)
DBG :looping indefenitely doing busy wait, waiting for exit signal
DBG :killing Silk#0
DBG :Silk#0 killed by non silk thread
DBG :send msg={code=3, id=0, ctx=(nil)}
DBG :wait for silk to call yield()
DBG :breaking out of busy-wait
DBG :recv msg={code=3, id=0, ctx=(nil)}
DBG :recycling a terminated Silk#0
!!! FIX ME !!! silk initialization code a bit duplicated above (SLIST)
DBG :send msg={code=1, id=0, ctx=(nil)}
DBG :Silk#0 booting...
DBG :recv msg={code=1, id=0, ctx=(nil)}
DBG :Silk#0 processing BOOT msg
ut_kill__idle_cb
DBG :wait for the silk to become free
DBG :Silk#0 is free
DBG :Now allocate a silk, make sure its the same instance we killed, dispatch it to see it running fine.
DBG :allocated Silk#0. still 3 available
DBG :dispatching Silk#0
DBG :send msg={code=2, id=0, ctx=(nil)}
DBG :recv msg={code=2, id=0, ctx=(nil)}
INFO:state= 2
INFO:silk 0 starting
INFO:silk 0 ended
ut_kill__idle_cb
Test Case 4
DBG :Stack range for Silk#0:start_stk_addr=0xb0010000, end_stk_addr=0xb0000000
DBG :-----------------iteration#0, path=1, depth=1------------------------
DBG :allocated Silk#0. still 3 available
DBG :dispatching Silk#0
DBG :send msg={code=2, id=0, ctx=(nil)}
DBG :recv msg={code=2, id=0, ctx=(nil)}
INFO:state= 2
INFO:silk 0 starting
DBG :ut_kill__main: Silk#0 starts... (oper=2)
DBG :Doing a 1 stack recursion ...
DBG :silk commits suicide
DBG :killing Silk#0
DBG :Silk#0 killed by silk thread
DBG :Silk#0 killing itself
DBG :send msg={code=3, id=0, ctx=(nil)}
DBG :recv msg={code=3, id=0, ctx=(nil)}
DBG :recycling a terminated Silk#0
!!! FIX ME !!! silk initialization code a bit duplicated above (SLIST)
DBG :send msg={code=1, id=0, ctx=(nil)}
DBG :Silk#0 booting...
DBG :recv msg={code=1, id=0, ctx=(nil)}
DBG :Silk#0 processing BOOT msg
ut_kill__idle_cb
DBG :SHALLOW: top_stack_frame_addr=0xb000ff6c, bottom_stack_frame_addr=0xb000ff38
DBG :stack being used by SHALLOW silk code:0x94 Bytes
DBG :-----------------iteration#0, path=1, depth=1000------------------------
DBG :allocated Silk#0. still 3 available
DBG :dispatching Silk#0
DBG :send msg={code=2, id=0, ctx=(nil)}
DBG :recv msg={code=2, id=0, ctx=(nil)}
INFO:state= 2
INFO:silk 0 starting
DBG :ut_kill__main: Silk#0 starts... (oper=2)
DBG :Doing a 1000 stack recursion ...
DBG :silk commits suicide
DBG :killing Silk#0
DBG :Silk#0 killed by silk thread
DBG :Silk#0 killing itself
DBG :send msg={code=3, id=0, ctx=(nil)}
DBG :recv msg={code=3, id=0, ctx=(nil)}
DBG :recycling a terminated Silk#0
!!! FIX ME !!! silk initialization code a bit duplicated above (SLIST)
DBG :send msg={code=1, id=0, ctx=(nil)}
DBG :Silk#0 booting...
DBG :recv msg={code=1, id=0, ctx=(nil)}
DBG :Silk#0 processing BOOT msg
ut_kill__idle_cb
DBG :DEEP: top_stack_frame_addr=0xb000ff6c, bottom_stack_frame_addr=0xb00043e8
DBG :stack being used by DEEP silk code:0xbc18 Bytes
DBG :saving stack addresses to compare on next runs
DBG :-----------------iteration#0, path=2, depth=1------------------------
DBG :allocated Silk#0. still 3 available
DBG :dispatching Silk#0
DBG :send msg={code=2, id=0, ctx=(nil)}
DBG :recv msg={code=2, id=0, ctx=(nil)}
INFO:state= 2
INFO:silk 0 starting
DBG :ut_kill__main: Silk#0 starts... (oper=2)
DBG :Doing a 1 stack recursion ...
DBG :calling yield
ut_kill__idle_cb
DBG :allocated Silk#1. still 2 available
DBG :start another silk (#1) to kill the first one
DBG :dispatching Silk#1
DBG :send msg={code=2, id=1, ctx=(nil)}
DBG :recv msg={code=2, id=1, ctx=(nil)}
DBG :switching from Silk#0 to Silk#1
DBG :switched into Silk#1
INFO:state= 2
INFO:silk 1 starting
DBG :Silk#1 start running - killing Silk#0
DBG :killing Silk#0
DBG :Silk#0 killed by silk thread
DBG :send msg={code=3, id=0, ctx=(nil)}
DBG :Silk#0 killed by Silk#1
INFO:silk 1 ended
DBG :recv msg={code=3, id=0, ctx=(nil)}
DBG :recycling a terminated Silk#0
!!! FIX ME !!! silk initialization code a bit duplicated above (SLIST)
DBG :send msg={code=1, id=0, ctx=(nil)}
DBG :send msg={code=1, id=0, ctx=(nil)}
DBG :recv msg={code=1, id=0, ctx=(nil)}
DBG :switching from Silk#1 to Silk#0
DBG :Silk#0 booting...
DBG :recv msg={code=1, id=0, ctx=(nil)}
DBG :Silk#0 processing BOOT msg
ut_kill__idle_cb
DBG :Silk#1 killed Silk#0
DBG :SHALLOW: top_stack_frame_addr=0xb000ff6c, bottom_stack_frame_addr=0xb000ff38
DBG :stack being used by SHALLOW silk code:0x94 Bytes
DBG :-----------------iteration#0, path=2, depth=1000------------------------
DBG :allocated Silk#0. still 3 available
DBG :dispatching Silk#0
DBG :send msg={code=2, id=0, ctx=(nil)}
DBG :recv msg={code=2, id=0, ctx=(nil)}
INFO:state= 2
INFO:silk 0 starting
DBG :ut_kill__main: Silk#0 starts... (oper=2)
DBG :Doing a 1000 stack recursion ...
DBG :calling yield
ut_kill__idle_cb
DBG :allocated Silk#1. still 2 available
DBG :start another silk (#1) to kill the first one
DBG :dispatching Silk#1
DBG :send msg={code=2, id=1, ctx=(nil)}
DBG :recv msg={code=2, id=1, ctx=(nil)}
DBG :switching from Silk#0 to Silk#1
DBG :switched into Silk#1
INFO:state= 2
INFO:silk 1 starting
DBG :Silk#1 start running - killing Silk#0
DBG :killing Silk#0
DBG :Silk#0 killed by silk thread
DBG :send msg={code=3, id=0, ctx=(nil)}
DBG :Silk#0 killed by Silk#1
INFO:silk 1 ended
DBG :recv msg={code=3, id=0, ctx=(nil)}
DBG :recycling a terminated Silk#0
!!! FIX ME !!! silk initialization code a bit duplicated above (SLIST)
DBG :send msg={code=1, id=0, ctx=(nil)}
DBG :send msg={code=1, id=0, ctx=(nil)}
DBG :recv msg={code=1, id=0, ctx=(nil)}
DBG :switching from Silk#1 to Silk#0
DBG :Silk#0 booting...
DBG :recv msg={code=1, id=0, ctx=(nil)}
DBG :Silk#0 processing BOOT msg
ut_kill__idle_cb
DBG :Silk#1 killed Silk#0
DBG :DEEP: top_stack_frame_addr=0xb000ff6c, bottom_stack_frame_addr=0xb00043e8
DBG :stack being used by DEEP silk code:0xbc18 Bytes
DBG :verifying stack addresses are identical to previous run
DBG :-----------------iteration#0, path=3, depth=1------------------------
DBG :allocated Silk#0. still 3 available
DBG :dispatching Silk#0
DBG :send msg={code=2, id=0, ctx=(nil)}
DBG :recv msg={code=2, id=0, ctx=(nil)}
INFO:state= 2
INFO:silk 0 starting
DBG :ut_kill__main: Silk#0 starts... (oper=2)
DBG :Doing a 1 stack recursion ...
DBG :I'm now waiting for a seconf silk to be dispatched (to issue the killed)
DBG :allocated Silk#1. still 2 available
DBG :start another silk (#1) to kill the first one after it would be killed
DBG :dispatching Silk#1
DBG :send msg={code=2, id=1, ctx=(nil)}
DBG :i'm returning (i.e.: silk terminates naturaly)
DBG :ut_kill__main: Silk#0 ends!!!
INFO:silk 0 ended
DBG :recv msg={code=2, id=1, ctx=(nil)}
DBG :switching from Silk#0 to Silk#1
DBG :switched into Silk#1
INFO:state= 2
INFO:silk 1 starting
DBG :Silk#1 start running - killing Silk#0
DBG :killing Silk#0
DBG :silk 0 is in state 1 - no point killing it.
INFO:silk 1 ended
ut_kill__idle_cb
DBG :SHALLOW: top_stack_frame_addr=0xb000ff6c, bottom_stack_frame_addr=0xb000ff38
DBG :stack being used by SHALLOW silk code:0x94 Bytes
DBG :-----------------iteration#0, path=3, depth=1000------------------------
DBG :allocated Silk#1. still 3 available
DBG :dispatching Silk#1
DBG :send msg={code=2, id=1, ctx=(nil)}
DBG :recv msg={code=2, id=1, ctx=(nil)}
INFO:state= 2
INFO:silk 1 starting
DBG :ut_kill__main: Silk#1 starts... (oper=2)
DBG :Doing a 1000 stack recursion ...
DBG :I'm now waiting for a seconf silk to be dispatched (to issue the killed)
DBG :allocated Silk#0. still 2 available
DBG :start another silk (#0) to kill the first one after it would be killed
DBG :dispatching Silk#0
DBG :send msg={code=2, id=0, ctx=(nil)}
DBG :i'm returning (i.e.: silk terminates naturaly)
DBG :ut_kill__main: Silk#1 ends!!!
INFO:silk 1 ended
DBG :recv msg={code=2, id=0, ctx=(nil)}
DBG :switching from Silk#1 to Silk#0
DBG :switched into Silk#0
INFO:state= 2
INFO:silk 0 starting
DBG :Silk#0 start running - killing Silk#1
DBG :killing Silk#1
DBG :silk 1 is in state 1 - no point killing it.
INFO:silk 0 ended
ut_kill__idle_cb
DBG :DEEP: top_stack_frame_addr=0xb0023f6c, bottom_stack_frame_addr=0xb00183e8
DBG :stack being used by DEEP silk code:0xffff7c18 Bytes
DBG :-----------------iteration#1, path=1, depth=1------------------------
DBG :allocated Silk#0. still 3 available
DBG :dispatching Silk#0
DBG :send msg={code=2, id=0, ctx=(nil)}
DBG :recv msg={code=2, id=0, ctx=(nil)}
INFO:state= 2
INFO:silk 0 starting
DBG :ut_kill__main: Silk#0 starts... (oper=2)
DBG :Doing a 1 stack recursion ...
DBG :silk commits suicide
DBG :killing Silk#0
DBG :Silk#0 killed by silk thread
DBG :Silk#0 killing itself
DBG :send msg={code=3, id=0, ctx=(nil)}
DBG :recv msg={code=3, id=0, ctx=(nil)}
DBG :recycling a terminated Silk#0
!!! FIX ME !!! silk initialization code a bit duplicated above (SLIST)
DBG :send msg={code=1, id=0, ctx=(nil)}
DBG :Silk#0 booting...
DBG :recv msg={code=1, id=0, ctx=(nil)}
DBG :Silk#0 processing BOOT msg
ut_kill__idle_cb
DBG :SHALLOW: top_stack_frame_addr=0xb000ff6c, bottom_stack_frame_addr=0xb000ff38
DBG :stack being used by SHALLOW silk code:0x94 Bytes
DBG :-----------------iteration#1, path=1, depth=1000------------------------
DBG :allocated Silk#0. still 3 available
DBG :dispatching Silk#0
DBG :send msg={code=2, id=0, ctx=(nil)}
DBG :recv msg={code=2, id=0, ctx=(nil)}
INFO:state= 2
INFO:silk 0 starting
DBG :ut_kill__main: Silk#0 starts... (oper=2)
DBG :Doing a 1000 stack recursion ...
DBG :silk commits suicide
DBG :killing Silk#0
DBG :Silk#0 killed by silk thread
DBG :Silk#0 killing itself
DBG :send msg={code=3, id=0, ctx=(nil)}
DBG :recv msg={code=3, id=0, ctx=(nil)}
DBG :recycling a terminated Silk#0
!!! FIX ME !!! silk initialization code a bit duplicated above (SLIST)
DBG :send msg={code=1, id=0, ctx=(nil)}
DBG :Silk#0 booting...
DBG :recv msg={code=1, id=0, ctx=(nil)}
DBG :Silk#0 processing BOOT msg
ut_kill__idle_cb
DBG :DEEP: top_stack_frame_addr=0xb000ff6c, bottom_stack_frame_addr=0xb00043e8
DBG :stack being used by DEEP silk code:0xbc18 Bytes
DBG :verifying stack addresses are identical to previous run
DBG :-----------------iteration#1, path=2, depth=1------------------------
DBG :allocated Silk#0. still 3 available
DBG :dispatching Silk#0
DBG :send msg={code=2, id=0, ctx=(nil)}
DBG :recv msg={code=2, id=0, ctx=(nil)}
INFO:state= 2
INFO:silk 0 starting
DBG :ut_kill__main: Silk#0 starts... (oper=2)
DBG :Doing a 1 stack recursion ...
DBG :calling yield
ut_kill__idle_cb
DBG :allocated Silk#1. still 2 available
DBG :start another silk (#1) to kill the first one
DBG :dispatching Silk#1
DBG :send msg={code=2, id=1, ctx=(nil)}
DBG :recv msg={code=2, id=1, ctx=(nil)}
DBG :switching from Silk#0 to Silk#1
DBG :switched into Silk#1
INFO:state= 2
INFO:silk 1 starting
DBG :Silk#1 start running - killing Silk#0
DBG :killing Silk#0
DBG :Silk#0 killed by silk thread
DBG :send msg={code=3, id=0, ctx=(nil)}
DBG :Silk#0 killed by Silk#1
INFO:silk 1 ended
DBG :recv msg={code=3, id=0, ctx=(nil)}
DBG :recycling a terminated Silk#0
!!! FIX ME !!! silk initialization code a bit duplicated above (SLIST)
DBG :send msg={code=1, id=0, ctx=(nil)}
DBG :send msg={code=1, id=0, ctx=(nil)}
DBG :recv msg={code=1, id=0, ctx=(nil)}
DBG :switching from Silk#1 to Silk#0
DBG :Silk#0 booting...
DBG :recv msg={code=1, id=0, ctx=(nil)}
DBG :Silk#0 processing BOOT msg
ut_kill__idle_cb
DBG :Silk#1 killed Silk#0
DBG :SHALLOW: top_stack_frame_addr=0xb000ff6c, bottom_stack_frame_addr=0xb000ff38
DBG :stack being used by SHALLOW silk code:0x94 Bytes
DBG :-----------------iteration#1, path=2, depth=1000------------------------
DBG :allocated Silk#0. still 3 available
DBG :dispatching Silk#0
DBG :send msg={code=2, id=0, ctx=(nil)}
DBG :recv msg={code=2, id=0, ctx=(nil)}
INFO:state= 2
INFO:silk 0 starting
DBG :ut_kill__main: Silk#0 starts... (oper=2)
DBG :Doing a 1000 stack recursion ...
DBG :calling yield
ut_kill__idle_cb
DBG :allocated Silk#1. still 2 available
DBG :start another silk (#1) to kill the first one
DBG :dispatching Silk#1
DBG :send msg={code=2, id=1, ctx=(nil)}
DBG :recv msg={code=2, id=1, ctx=(nil)}
DBG :switching from Silk#0 to Silk#1
DBG :switched into Silk#1
INFO:state= 2
INFO:silk 1 starting
DBG :Silk#1 start running - killing Silk#0
DBG :killing Silk#0
DBG :Silk#0 killed by silk thread
DBG :send msg={code=3, id=0, ctx=(nil)}
DBG :Silk#0 killed by Silk#1
INFO:silk 1 ended
DBG :recv msg={code=3, id=0, ctx=(nil)}
DBG :recycling a terminated Silk#0
!!! FIX ME !!! silk initialization code a bit duplicated above (SLIST)
DBG :send msg={code=1, id=0, ctx=(nil)}
DBG :send msg={code=1, id=0, ctx=(nil)}
DBG :recv msg={code=1, id=0, ctx=(nil)}
DBG :switching from Silk#1 to Silk#0
DBG :Silk#0 booting...
DBG :recv msg={code=1, id=0, ctx=(nil)}
DBG :Silk#0 processing BOOT msg
ut_kill__idle_cb
DBG :Silk#1 killed Silk#0
DBG :DEEP: top_stack_frame_addr=0xb000ff6c, bottom_stack_frame_addr=0xb00043e8
DBG :stack being used by DEEP silk code:0xbc18 Bytes
DBG :verifying stack addresses are identical to previous run
DBG :-----------------iteration#1, path=3, depth=1------------------------
DBG :allocated Silk#0. still 3 available
DBG :dispatching Silk#0
DBG :send msg={code=2, id=0, ctx=(nil)}
DBG :recv msg={code=2, id=0, ctx=(nil)}
INFO:state= 2
INFO:silk 0 starting
DBG :ut_kill__main: Silk#0 starts... (oper=2)
DBG :Doing a 1 stack recursion ...
DBG :I'm now waiting for a seconf silk to be dispatched (to issue the killed)
DBG :allocated Silk#1. still 2 available
DBG :start another silk (#1) to kill the first one after it would be killed
DBG :dispatching Silk#1
DBG :send msg={code=2, id=1, ctx=(nil)}
DBG :i'm returning (i.e.: silk terminates naturaly)
DBG :ut_kill__main: Silk#0 ends!!!
INFO:silk 0 ended
DBG :recv msg={code=2, id=1, ctx=(nil)}
DBG :switching from Silk#0 to Silk#1
DBG :switched into Silk#1
INFO:state= 2
INFO:silk 1 starting
DBG :Silk#1 start running - killing Silk#0
DBG :killing Silk#0
DBG :silk 0 is in state 1 - no point killing it.
INFO:silk 1 ended
ut_kill__idle_cb
DBG :SHALLOW: top_stack_frame_addr=0xb000ff6c, bottom_stack_frame_addr=0xb000ff38
DBG :stack being used by SHALLOW silk code:0x94 Bytes
DBG :-----------------iteration#1, path=3, depth=1000------------------------
DBG :allocated Silk#1. still 3 available
DBG :dispatching Silk#1
DBG :send msg={code=2, id=1, ctx=(nil)}
DBG :recv msg={code=2, id=1, ctx=(nil)}
INFO:state= 2
INFO:silk 1 starting
DBG :ut_kill__main: Silk#1 starts... (oper=2)
DBG :Doing a 1000 stack recursion ...
DBG :I'm now waiting for a seconf silk to be dispatched (to issue the killed)
DBG :allocated Silk#0. still 2 available
DBG :start another silk (#0) to kill the first one after it would be killed
DBG :dispatching Silk#0
DBG :send msg={code=2, id=0, ctx=(nil)}
DBG :i'm returning (i.e.: silk terminates naturaly)
DBG :ut_kill__main: Silk#1 ends!!!
INFO:silk 1 ended
DBG :recv msg={code=2, id=0, ctx=(nil)}
DBG :switching from Silk#1 to Silk#0
DBG :switched into Silk#0
INFO:state= 2
INFO:silk 0 starting
DBG :Silk#0 start running - killing Silk#1
DBG :killing Silk#1
DBG :silk 1 is in state 1 - no point killing it.
INFO:silk 0 ended
ut_kill__idle_cb
DBG :DEEP: top_stack_frame_addr=0xb0023f6c, bottom_stack_frame_addr=0xb00183e8
DBG :stack being used by DEEP silk code:0xffff7c18 Bytes
DBG :-----------------iteration#2, path=1, depth=1------------------------
DBG :allocated Silk#0. still 3 available
DBG :dispatching Silk#0
DBG :send msg={code=2, id=0, ctx=(nil)}
DBG :recv msg={code=2, id=0, ctx=(nil)}
INFO:state= 2
INFO:silk 0 starting
DBG :ut_kill__main: Silk#0 starts... (oper=2)
DBG :Doing a 1 stack recursion ...
DBG :silk commits suicide
DBG :killing Silk#0
DBG :Silk#0 killed by silk thread
DBG :Silk#0 killing itself
DBG :send msg={code=3, id=0, ctx=(nil)}
DBG :recv msg={code=3, id=0, ctx=(nil)}
DBG :recycling a terminated Silk#0
!!! FIX ME !!! silk initialization code a bit duplicated above (SLIST)
DBG :send msg={code=1, id=0, ctx=(nil)}
DBG :Silk#0 booting...
DBG :recv msg={code=1, id=0, ctx=(nil)}
DBG :Silk#0 processing BOOT msg
ut_kill__idle_cb
DBG :SHALLOW: top_stack_frame_addr=0xb000ff6c, bottom_stack_frame_addr=0xb000ff38
DBG :stack being used by SHALLOW silk code:0x94 Bytes
DBG :-----------------iteration#2, path=1, depth=1000------------------------
DBG :allocated Silk#0. still 3 available
DBG :dispatching Silk#0
DBG :send msg={code=2, id=0, ctx=(nil)}
DBG :recv msg={code=2, id=0, ctx=(nil)}
INFO:state= 2
INFO:silk 0 starting
DBG :ut_kill__main: Silk#0 starts... (oper=2)
DBG :Doing a 1000 stack recursion ...
DBG :silk commits suicide
DBG :killing Silk#0
DBG :Silk#0 killed by silk thread
DBG :Silk#0 killing itself
DBG :send msg={code=3, id=0, ctx=(nil)}
DBG :recv msg={code=3, id=0, ctx=(nil)}
DBG :recycling a terminated Silk#0
!!! FIX ME !!! silk initialization code a bit duplicated above (SLIST)
DBG :send msg={code=1, id=0, ctx=(nil)}
DBG :Silk#0 booting...
DBG :recv msg={code=1, id=0, ctx=(nil)}
DBG :Silk#0 processing BOOT msg
ut_kill__idle_cb
DBG :DEEP: top_stack_frame_addr=0xb000ff6c, bottom_stack_frame_addr=0xb00043e8
DBG :stack being used by DEEP silk code:0xbc18 Bytes
DBG :verifying stack addresses are identical to previous run
DBG :-----------------iteration#2, path=2, depth=1------------------------
DBG :allocated Silk#0. still 3 available
DBG :dispatching Silk#0
DBG :send msg={code=2, id=0, ctx=(nil)}
DBG :recv msg={code=2, id=0, ctx=(nil)}
INFO:state= 2
INFO:silk 0 starting
DBG :ut_kill__main: Silk#0 starts... (oper=2)
DBG :Doing a 1 stack recursion ...
DBG :calling yield
ut_kill__idle_cb
DBG :allocated Silk#1. still 2 available
DBG :start another silk (#1) to kill the first one
DBG :dispatching Silk#1
DBG :send msg={code=2, id=1, ctx=(nil)}
DBG :recv msg={code=2, id=1, ctx=(nil)}
DBG :switching from Silk#0 to Silk#1
DBG :switched into Silk#1
INFO:state= 2
INFO:silk 1 starting
DBG :Silk#1 start running - killing Silk#0
DBG :killing Silk#0
DBG :Silk#0 killed by silk thread
DBG :send msg={code=3, id=0, ctx=(nil)}
DBG :Silk#0 killed by Silk#1
INFO:silk 1 ended
DBG :recv msg={code=3, id=0, ctx=(nil)}
DBG :recycling a terminated Silk#0
!!! FIX ME !!! silk initialization code a bit duplicated above (SLIST)
DBG :send msg={code=1, id=0, ctx=(nil)}
DBG :send msg={code=1, id=0, ctx=(nil)}
DBG :recv msg={code=1, id=0, ctx=(nil)}
DBG :switching from Silk#1 to Silk#0
DBG :Silk#0 booting...
DBG :recv msg={code=1, id=0, ctx=(nil)}
DBG :Silk#0 processing BOOT msg
ut_kill__idle_cb
DBG :Silk#1 killed Silk#0
DBG :SHALLOW: top_stack_frame_addr=0xb000ff6c, bottom_stack_frame_addr=0xb000ff38
DBG :stack being used by SHALLOW silk code:0x94 Bytes
DBG :-----------------iteration#2, path=2, depth=1000------------------------
DBG :allocated Silk#0. still 3 available
DBG :dispatching Silk#0
DBG :send msg={code=2, id=0, ctx=(nil)}
DBG :recv msg={code=2, id=0, ctx=(nil)}
INFO:state= 2
INFO:silk 0 starting
DBG :ut_kill__main: Silk#0 starts... (oper=2)
DBG :Doing a 1000 stack recursion ...
DBG :calling yield
ut_kill__idle_cb
DBG :allocated Silk#1. still 2 available
DBG :start another silk (#1) to kill the first one
DBG :dispatching Silk#1
DBG :send msg={code=2, id=1, ctx=(nil)}
DBG :recv msg={code=2, id=1, ctx=(nil)}
DBG :switching from Silk#0 to Silk#1
DBG :switched into Silk#1
INFO:state= 2
INFO:silk 1 starting
DBG :Silk#1 start running - killing Silk#0
DBG :killing Silk#0
DBG :Silk#0 killed by silk thread
DBG :send msg={code=3, id=0, ctx=(nil)}
DBG :Silk#0 killed by Silk#1
INFO:silk 1 ended
DBG :recv msg={code=3, id=0, ctx=(nil)}
DBG :recycling a terminated Silk#0
!!! FIX ME !!! silk initialization code a bit duplicated above (SLIST)
DBG :send msg={code=1, id=0, ctx=(nil)}
DBG :send msg={code=1, id=0, ctx=(nil)}
DBG :recv msg={code=1, id=0, ctx=(nil)}
DBG :switching from Silk#1 to Silk#0
DBG :Silk#0 booting...
DBG :recv msg={code=1, id=0, ctx=(nil)}
DBG :Silk#0 processing BOOT msg
ut_kill__idle_cb
DBG :Silk#1 killed Silk#0
DBG :DEEP: top_stack_frame_addr=0xb000ff6c, bottom_stack_frame_addr=0xb00043e8
DBG :stack being used by DEEP silk code:0xbc18 Bytes
DBG :verifying stack addresses are identical to previous run
DBG :-----------------iteration#2, path=3, depth=1------------------------
DBG :allocated Silk#0. still 3 available
DBG :dispatching Silk#0
DBG :send msg={code=2, id=0, ctx=(nil)}
DBG :recv msg={code=2, id=0, ctx=(nil)}
INFO:state= 2
INFO:silk 0 starting
DBG :ut_kill__main: Silk#0 starts... (oper=2)
DBG :Doing a 1 stack recursion ...
DBG :I'm now waiting for a seconf silk to be dispatched (to issue the killed)
DBG :allocated Silk#1. still 2 available
DBG :start another silk (#1) to kill the first one after it would be killed
DBG :dispatching Silk#1
DBG :send msg={code=2, id=1, ctx=(nil)}
DBG :i'm returning (i.e.: silk terminates naturaly)
DBG :ut_kill__main: Silk#0 ends!!!
INFO:silk 0 ended
DBG :recv msg={code=2, id=1, ctx=(nil)}
DBG :switching from Silk#0 to Silk#1
DBG :switched into Silk#1
INFO:state= 2
INFO:silk 1 starting
DBG :Silk#1 start running - killing Silk#0
DBG :killing Silk#0
DBG :silk 0 is in state 1 - no point killing it.
INFO:silk 1 ended
ut_kill__idle_cb
DBG :SHALLOW: top_stack_frame_addr=0xb000ff6c, bottom_stack_frame_addr=0xb000ff38
DBG :stack being used by SHALLOW silk code:0x94 Bytes
DBG :-----------------iteration#2, path=3, depth=1000------------------------
DBG :allocated Silk#1. still 3 available
DBG :dispatching Silk#1
DBG :send msg={code=2, id=1, ctx=(nil)}
DBG :recv msg={code=2, id=1, ctx=(nil)}
INFO:state= 2
INFO:silk 1 starting
DBG :ut_kill__main: Silk#1 starts... (oper=2)
DBG :Doing a 1000 stack recursion ...
DBG :I'm now waiting for a seconf silk to be dispatched (to issue the killed)
DBG :allocated Silk#0. still 2 available
DBG :start another silk (#0) to kill the first one after it would be killed
DBG :dispatching Silk#0
DBG :send msg={code=2, id=0, ctx=(nil)}
DBG :i'm returning (i.e.: silk terminates naturaly)
DBG :ut_kill__main: Silk#1 ends!!!
INFO:silk 1 ended
DBG :recv msg={code=2, id=0, ctx=(nil)}
DBG :switching from Silk#1 to Silk#0
DBG :switched into Silk#0
INFO:state= 2
INFO:silk 0 starting
DBG :Silk#0 start running - killing Silk#1
DBG :killing Silk#1
DBG :silk 1 is in state 1 - no point killing it.
INFO:silk 0 ended
ut_kill__idle_cb
DBG :DEEP: top_stack_frame_addr=0xb0023f6c, bottom_stack_frame_addr=0xb00183e8
DBG :stack being used by DEEP silk code:0xffff7c18 Bytes
DBG :-----------------iteration#3, path=1, depth=1------------------------
DBG :allocated Silk#0. still 3 available
DBG :dispatching Silk#0
DBG :send msg={code=2, id=0, ctx=(nil)}
DBG :recv msg={code=2, id=0, ctx=(nil)}
INFO:state= 2
INFO:silk 0 starting
DBG :ut_kill__main: Silk#0 starts... (oper=2)
DBG :Doing a 1 stack recursion ...
DBG :silk commits suicide
DBG :killing Silk#0
DBG :Silk#0 killed by silk thread
DBG :Silk#0 killing itself
DBG :send msg={code=3, id=0, ctx=(nil)}
DBG :recv msg={code=3, id=0, ctx=(nil)}
DBG :recycling a terminated Silk#0
!!! FIX ME !!! silk initialization code a bit duplicated above (SLIST)
DBG :send msg={code=1, id=0, ctx=(nil)}
DBG :Silk#0 booting...
DBG :recv msg={code=1, id=0, ctx=(nil)}
DBG :Silk#0 processing BOOT msg
ut_kill__idle_cb
DBG :SHALLOW: top_stack_frame_addr=0xb000ff6c, bottom_stack_frame_addr=0xb000ff38
DBG :stack being used by SHALLOW silk code:0x94 Bytes
DBG :-----------------iteration#3, path=1, depth=1000------------------------
DBG :allocated Silk#0. still 3 available
DBG :dispatching Silk#0
DBG :send msg={code=2, id=0, ctx=(nil)}
DBG :recv msg={code=2, id=0, ctx=(nil)}
INFO:state= 2
INFO:silk 0 starting
DBG :ut_kill__main: Silk#0 starts... (oper=2)
DBG :Doing a 1000 stack recursion ...
DBG :silk commits suicide
DBG :killing Silk#0
DBG :Silk#0 killed by silk thread
DBG :Silk#0 killing itself
DBG :send msg={code=3, id=0, ctx=(nil)}
DBG :recv msg={code=3, id=0, ctx=(nil)}
DBG :recycling a terminated Silk#0
!!! FIX ME !!! silk initialization code a bit duplicated above (SLIST)
DBG :send msg={code=1, id=0, ctx=(nil)}
DBG :Silk#0 booting...
DBG :recv msg={code=1, id=0, ctx=(nil)}
DBG :Silk#0 processing BOOT msg
ut_kill__idle_cb
DBG :DEEP: top_stack_frame_addr=0xb000ff6c, bottom_stack_frame_addr=0xb00043e8
DBG :stack being used by DEEP silk code:0xbc18 Bytes
DBG :verifying stack addresses are identical to previous run
DBG :-----------------iteration#3, path=2, depth=1------------------------
DBG :allocated Silk#0. still 3 available
DBG :dispatching Silk#0
DBG :send msg={code=2, id=0, ctx=(nil)}
DBG :recv msg={code=2, id=0, ctx=(nil)}
INFO:state= 2
INFO:silk 0 starting
DBG :ut_kill__main: Silk#0 starts... (oper=2)
DBG :Doing a 1 stack recursion ...
DBG :calling yield
ut_kill__idle_cb
DBG :allocated Silk#1. still 2 available
DBG :start another silk (#1) to kill the first one
DBG :dispatching Silk#1
DBG :send msg={code=2, id=1, ctx=(nil)}
DBG :recv msg={code=2, id=1, ctx=(nil)}
DBG :switching from Silk#0 to Silk#1
DBG :switched into Silk#1
INFO:state= 2
INFO:silk 1 starting
DBG :Silk#1 start running - killing Silk#0
DBG :killing Silk#0
DBG :Silk#0 killed by silk thread
DBG :send msg={code=3, id=0, ctx=(nil)}
DBG :Silk#0 killed by Silk#1
INFO:silk 1 ended
DBG :recv msg={code=3, id=0, ctx=(nil)}
DBG :recycling a terminated Silk#0
!!! FIX ME !!! silk initialization code a bit duplicated above (SLIST)
DBG :send msg={code=1, id=0, ctx=(nil)}
DBG :send msg={code=1, id=0, ctx=(nil)}
DBG :recv msg={code=1, id=0, ctx=(nil)}
DBG :switching from Silk#1 to Silk#0
DBG :Silk#0 booting...
DBG :recv msg={code=1, id=0, ctx=(nil)}
DBG :Silk#0 processing BOOT msg
ut_kill__idle_cb
DBG :Silk#1 killed Silk#0
DBG :SHALLOW: top_stack_frame_addr=0xb000ff6c, bottom_stack_frame_addr=0xb000ff38
DBG :stack being used by SHALLOW silk code:0x94 Bytes
DBG :-----------------iteration#3, path=2, depth=1000------------------------
DBG :allocated Silk#0. still 3 available
DBG :dispatching Silk#0
DBG :send msg={code=2, id=0, ctx=(nil)}
DBG :recv msg={code=2, id=0, ctx=(nil)}
INFO:state= 2
INFO:silk 0 starting
DBG :ut_kill__main: Silk#0 starts... (oper=2)
DBG :Doing a 1000 stack recursion ...
DBG :calling yield
ut_kill__idle_cb
DBG :allocated Silk#1. still 2 available
DBG :start another silk (#1) to kill the first one
DBG :dispatching Silk#1
DBG :send msg={code=2, id=1, ctx=(nil)}
DBG :recv msg={code=2, id=1, ctx=(nil)}
DBG :switching from Silk#0 to Silk#1
DBG :switched into Silk#1
INFO:state= 2
INFO:silk 1 starting
DBG :Silk#1 start running - killing Silk#0
DBG :killing Silk#0
DBG :Silk#0 killed by silk thread
DBG :send msg={code=3, id=0, ctx=(nil)}
DBG :Silk#0 killed by Silk#1
INFO:silk 1 ended
DBG :recv msg={code=3, id=0, ctx=(nil)}
DBG :recycling a terminated Silk#0
!!! FIX ME !!! silk initialization code a bit duplicated above (SLIST)
DBG :send msg={code=1, id=0, ctx=(nil)}
DBG :send msg={code=1, id=0, ctx=(nil)}
DBG :recv msg={code=1, id=0, ctx=(nil)}
DBG :switching from Silk#1 to Silk#0
DBG :Silk#0 booting...
DBG :recv msg={code=1, id=0, ctx=(nil)}
DBG :Silk#0 processing BOOT msg
ut_kill__idle_cb
DBG :Silk#1 killed Silk#0
DBG :DEEP: top_stack_frame_addr=0xb000ff6c, bottom_stack_frame_addr=0xb00043e8
DBG :stack being used by DEEP silk code:0xbc18 Bytes
DBG :verifying stack addresses are identical to previous run
DBG :-----------------iteration#3, path=3, depth=1------------------------
DBG :allocated Silk#0. still 3 available
DBG :dispatching Silk#0
DBG :send msg={code=2, id=0, ctx=(nil)}
DBG :recv msg={code=2, id=0, ctx=(nil)}
INFO:state= 2
INFO:silk 0 starting
DBG :ut_kill__main: Silk#0 starts... (oper=2)
DBG :Doing a 1 stack recursion ...
DBG :I'm now waiting for a seconf silk to be dispatched (to issue the killed)
DBG :allocated Silk#1. still 2 available
DBG :start another silk (#1) to kill the first one after it would be killed
DBG :dispatching Silk#1
DBG :send msg={code=2, id=1, ctx=(nil)}
DBG :i'm returning (i.e.: silk terminates naturaly)
DBG :ut_kill__main: Silk#0 ends!!!
INFO:silk 0 ended
DBG :recv msg={code=2, id=1, ctx=(nil)}
DBG :switching from Silk#0 to Silk#1
DBG :switched into Silk#1
INFO:state= 2
INFO:silk 1 starting
DBG :Silk#1 start running - killing Silk#0
DBG :killing Silk#0
DBG :silk 0 is in state 1 - no point killing it.
INFO:silk 1 ended
ut_kill__idle_cb
DBG :SHALLOW: top_stack_frame_addr=0xb000ff6c, bottom_stack_frame_addr=0xb000ff38
DBG :stack being used by SHALLOW silk code:0x94 Bytes
DBG :-----------------iteration#3, path=3, depth=1000------------------------
DBG :allocated Silk#1. still 3 available
DBG :dispatching Silk#1
DBG :send msg={code=2, id=1, ctx=(nil)}
DBG :recv msg={code=2, id=1, ctx=(nil)}
INFO:state= 2
INFO:silk 1 starting
DBG :ut_kill__main: Silk#1 starts... (oper=2)
DBG :Doing a 1000 stack recursion ...
DBG :I'm now waiting for a seconf silk to be dispatched (to issue the killed)
DBG :allocated Silk#0. still 2 available
DBG :start another silk (#0) to kill the first one after it would be killed
DBG :dispatching Silk#0
DBG :send msg={code=2, id=0, ctx=(nil)}
DBG :i'm returning (i.e.: silk terminates naturaly)
DBG :ut_kill__main: Silk#1 ends!!!
INFO:silk 1 ended
DBG :recv msg={code=2, id=0, ctx=(nil)}
DBG :switching from Silk#1 to Silk#0
DBG :switched into Silk#0
INFO:state= 2
INFO:silk 0 starting
DBG :Silk#0 start running - killing Silk#1
DBG :killing Silk#1
DBG :silk 1 is in state 1 - no point killing it.
INFO:silk 0 ended
ut_kill__idle_cb
DBG :DEEP: top_stack_frame_addr=0xb0023f6c, bottom_stack_frame_addr=0xb00183e8
DBG :stack being used by DEEP silk code:0xffff7c18 Bytes
DBG :-----------------iteration#4, path=1, depth=1------------------------
DBG :allocated Silk#0. still 3 available
DBG :dispatching Silk#0
DBG :send msg={code=2, id=0, ctx=(nil)}
DBG :recv msg={code=2, id=0, ctx=(nil)}
INFO:state= 2
INFO:silk 0 starting
DBG :ut_kill__main: Silk#0 starts... (oper=2)
DBG :Doing a 1 stack recursion ...
DBG :silk commits suicide
DBG :killing Silk#0
DBG :Silk#0 killed by silk thread
DBG :Silk#0 killing itself
DBG :send msg={code=3, id=0, ctx=(nil)}
DBG :recv msg={code=3, id=0, ctx=(nil)}
DBG :recycling a terminated Silk#0
!!! FIX ME !!! silk initialization code a bit duplicated above (SLIST)
DBG :send msg={code=1, id=0, ctx=(nil)}
DBG :Silk#0 booting...
DBG :recv msg={code=1, id=0, ctx=(nil)}
DBG :Silk#0 processing BOOT msg
ut_kill__idle_cb
DBG :SHALLOW: top_stack_frame_addr=0xb000ff6c, bottom_stack_frame_addr=0xb000ff38
DBG :stack being used by SHALLOW silk code:0x94 Bytes
DBG :-----------------iteration#4, path=1, depth=1000------------------------
DBG :allocated Silk#0. still 3 available
DBG :dispatching Silk#0
DBG :send msg={code=2, id=0, ctx=(nil)}
DBG :recv msg={code=2, id=0, ctx=(nil)}
INFO:state= 2
INFO:silk 0 starting
DBG :ut_kill__main: Silk#0 starts... (oper=2)
DBG :Doing a 1000 stack recursion ...
DBG :silk commits suicide
DBG :killing Silk#0
DBG :Silk#0 killed by silk thread
DBG :Silk#0 killing itself
DBG :send msg={code=3, id=0, ctx=(nil)}
DBG :recv msg={code=3, id=0, ctx=(nil)}
DBG :recycling a terminated Silk#0
!!! FIX ME !!! silk initialization code a bit duplicated above (SLIST)
DBG :send msg={code=1, id=0, ctx=(nil)}
DBG :Silk#0 booting...
DBG :recv msg={code=1, id=0, ctx=(nil)}
DBG :Silk#0 processing BOOT msg
ut_kill__idle_cb
DBG :DEEP: top_stack_frame_addr=0xb000ff6c, bottom_stack_frame_addr=0xb00043e8
DBG :stack being used by DEEP silk code:0xbc18 Bytes
DBG :verifying stack addresses are identical to previous run
DBG :-----------------iteration#4, path=2, depth=1------------------------
DBG :allocated Silk#0. still 3 available
DBG :dispatching Silk#0
DBG :send msg={code=2, id=0, ctx=(nil)}
DBG :recv msg={code=2, id=0, ctx=(nil)}
INFO:state= 2
INFO:silk 0 starting
DBG :ut_kill__main: Silk#0 starts... (oper=2)
DBG :Doing a 1 stack recursion ...
DBG :calling yield
ut_kill__idle_cb
DBG :allocated Silk#1. still 2 available
DBG :start another silk (#1) to kill the first one
DBG :dispatching Silk#1
DBG :send msg={code=2, id=1, ctx=(nil)}
DBG :recv msg={code=2, id=1, ctx=(nil)}
DBG :switching from Silk#0 to Silk#1
DBG :switched into Silk#1
INFO:state= 2
INFO:silk 1 starting
DBG :Silk#1 start running - killing Silk#0
DBG :killing Silk#0
DBG :Silk#0 killed by silk thread
DBG :send msg={code=3, id=0, ctx=(nil)}
DBG :Silk#0 killed by Silk#1
INFO:silk 1 ended
DBG :recv msg={code=3, id=0, ctx=(nil)}
DBG :recycling a terminated Silk#0
!!! FIX ME !!! silk initialization code a bit duplicated above (SLIST)
DBG :send msg={code=1, id=0, ctx=(nil)}
DBG :send msg={code=1, id=0, ctx=(nil)}
DBG :recv msg={code=1, id=0, ctx=(nil)}
DBG :switching from Silk#1 to Silk#0
DBG :Silk#0 booting...
DBG :recv msg={code=1, id=0, ctx=(nil)}
DBG :Silk#0 processing BOOT msg
ut_kill__idle_cb
DBG :Silk#1 killed Silk#0
DBG :SHALLOW: top_stack_frame_addr=0xb000ff6c, bottom_stack_frame_addr=0xb000ff38
DBG :stack being used by SHALLOW silk code:0x94 Bytes
DBG :-----------------iteration#4, path=2, depth=1000------------------------
DBG :allocated Silk#0. still 3 available
DBG :dispatching Silk#0
DBG :send msg={code=2, id=0, ctx=(nil)}
DBG :recv msg={code=2, id=0, ctx=(nil)}
INFO:state= 2
INFO:silk 0 starting
DBG :ut_kill__main: Silk#0 starts... (oper=2)
DBG :Doing a 1000 stack recursion ...
DBG :calling yield
ut_kill__idle_cb
DBG :allocated Silk#1. still 2 available
DBG :start another silk (#1) to kill the first one
DBG :dispatching Silk#1
DBG :send msg={code=2, id=1, ctx=(nil)}
DBG :recv msg={code=2, id=1, ctx=(nil)}
DBG :switching from Silk#0 to Silk#1
DBG :switched into Silk#1
INFO:state= 2
INFO:silk 1 starting
DBG :Silk#1 start running - killing Silk#0
DBG :killing Silk#0
DBG :Silk#0 killed by silk thread
DBG :send msg={code=3, id=0, ctx=(nil)}
DBG :Silk#0 killed by Silk#1
INFO:silk 1 ended
DBG :recv msg={code=3, id=0, ctx=(nil)}
DBG :recycling a terminated Silk#0
!!! FIX ME !!! silk initialization code a bit duplicated above (SLIST)
DBG :send msg={code=1, id=0, ctx=(nil)}
DBG :send msg={code=1, id=0, ctx=(nil)}
DBG :recv msg={code=1, id=0, ctx=(nil)}
DBG :switching from Silk#1 to Silk#0
DBG :Silk#0 booting...
DBG :recv msg={code=1, id=0, ctx=(nil)}
DBG :Silk#0 processing BOOT msg
ut_kill__idle_cb
DBG :Silk#1 killed Silk#0
DBG :DEEP: top_stack_frame_addr=0xb000ff6c, bottom_stack_frame_addr=0xb00043e8
DBG :stack being used by DEEP silk code:0xbc18 Bytes
DBG :verifying stack addresses are identical to previous run
DBG :-----------------iteration#4, path=3, depth=1------------------------
DBG :allocated Silk#0. still 3 available
DBG :dispatching Silk#0
DBG :send msg={code=2, id=0, ctx=(nil)}
DBG :recv msg={code=2, id=0, ctx=(nil)}
INFO:state= 2
INFO:silk 0 starting
DBG :ut_kill__main: Silk#0 starts... (oper=2)
DBG :Doing a 1 stack recursion ...
DBG :I'm now waiting for a seconf silk to be dispatched (to issue the killed)
DBG :allocated Silk#1. still 2 available
DBG :start another silk (#1) to kill the first one after it would be killed
DBG :dispatching Silk#1
DBG :send msg={code=2, id=1, ctx=(nil)}
DBG :i'm returning (i.e.: silk terminates naturaly)
DBG :ut_kill__main: Silk#0 ends!!!
INFO:silk 0 ended
DBG :recv msg={code=2, id=1, ctx=(nil)}
DBG :switching from Silk#0 to Silk#1
DBG :switched into Silk#1
INFO:state= 2
INFO:silk 1 starting
DBG :Silk#1 start running - killing Silk#0
DBG :killing Silk#0
DBG :silk 0 is in state 1 - no point killing it.
INFO:silk 1 ended
ut_kill__idle_cb
DBG :SHALLOW: top_stack_frame_addr=0xb000ff6c, bottom_stack_frame_addr=0xb000ff38
DBG :stack being used by SHALLOW silk code:0x94 Bytes
DBG :-----------------iteration#4, path=3, depth=1000------------------------
DBG :allocated Silk#1. still 3 available
DBG :dispatching Silk#1
DBG :send msg={code=2, id=1, ctx=(nil)}
DBG :recv msg={code=2, id=1, ctx=(nil)}
INFO:state= 2
INFO:silk 1 starting
DBG :ut_kill__main: Silk#1 starts... (oper=2)
DBG :Doing a 1000 stack recursion ...
DBG :I'm now waiting for a seconf silk to be dispatched (to issue the killed)
DBG :allocated Silk#0. still 2 available
DBG :start another silk (#0) to kill the first one after it would be killed
DBG :dispatching Silk#0
DBG :send msg={code=2, id=0, ctx=(nil)}
DBG :i'm returning (i.e.: silk terminates naturaly)
DBG :ut_kill__main: Silk#1 ends!!!
INFO:silk 1 ended
DBG :recv msg={code=2, id=0, ctx=(nil)}
DBG :switching from Silk#1 to Silk#0
DBG :switched into Silk#0
INFO:state= 2
INFO:silk 0 starting
DBG :Silk#0 start running - killing Silk#1
DBG :killing Silk#1
DBG :silk 1 is in state 1 - no point killing it.
INFO:silk 0 ended
ut_kill__idle_cb
DBG :DEEP: top_stack_frame_addr=0xb0023f6c, bottom_stack_frame_addr=0xb00183e8
DBG :stack being used by DEEP silk code:0xffff7c18 Bytes
DBG :-----------------iteration#5, path=1, depth=1------------------------
DBG :allocated Silk#0. still 3 available
DBG :dispatching Silk#0
DBG :send msg={code=2, id=0, ctx=(nil)}
DBG :recv msg={code=2, id=0, ctx=(nil)}
INFO:state= 2
INFO:silk 0 starting
DBG :ut_kill__main: Silk#0 starts... (oper=2)
DBG :Doing a 1 stack recursion ...
DBG :silk commits suicide
DBG :killing Silk#0
DBG :Silk#0 killed by silk thread
DBG :Silk#0 killing itself
DBG :send msg={code=3, id=0, ctx=(nil)}
DBG :recv msg={code=3, id=0, ctx=(nil)}
DBG :recycling a terminated Silk#0
!!! FIX ME !!! silk initialization code a bit duplicated above (SLIST)
DBG :send msg={code=1, id=0, ctx=(nil)}
DBG :Silk#0 booting...
DBG :recv msg={code=1, id=0, ctx=(nil)}
DBG :Silk#0 processing BOOT msg
ut_kill__idle_cb
DBG :SHALLOW: top_stack_frame_addr=0xb000ff6c, bottom_stack_frame_addr=0xb000ff38
DBG :stack being used by SHALLOW silk code:0x94 Bytes
DBG :-----------------iteration#5, path=1, depth=1000------------------------
DBG :allocated Silk#0. still 3 available
DBG :dispatching Silk#0
DBG :send msg={code=2, id=0, ctx=(nil)}
DBG :recv msg={code=2, id=0, ctx=(nil)}
INFO:state= 2
INFO:silk 0 starting
DBG :ut_kill__main: Silk#0 starts... (oper=2)
DBG :Doing a 1000 stack recursion ...
DBG :silk commits suicide
DBG :killing Silk#0
DBG :Silk#0 killed by silk thread
DBG :Silk#0 killing itself
DBG :send msg={code=3, id=0, ctx=(nil)}
DBG :recv msg={code=3, id=0, ctx=(nil)}
DBG :recycling a terminated Silk#0
!!! FIX ME !!! silk initialization code a bit duplicated above (SLIST)
DBG :send msg={code=1, id=0, ctx=(nil)}
DBG :Silk#0 booting...
DBG :recv msg={code=1, id=0, ctx=(nil)}
DBG :Silk#0 processing BOOT msg
ut_kill__idle_cb
DBG :DEEP: top_stack_frame_addr=0xb000ff6c, bottom_stack_frame_addr=0xb00043e8
DBG :stack being used by DEEP silk code:0xbc18 Bytes
DBG :verifying stack addresses are identical to previous run
DBG :-----------------iteration#5, path=2, depth=1------------------------
DBG :allocated Silk#0. still 3 available
DBG :dispatching Silk#0
DBG :send msg={code=2, id=0, ctx=(nil)}
DBG :recv msg={code=2, id=0, ctx=(nil)}
INFO:state= 2
INFO:silk 0 starting
DBG :ut_kill__main: Silk#0 starts... (oper=2)
DBG :Doing a 1 stack recursion ...
DBG :calling yield
ut_kill__idle_cb
DBG :allocated Silk#1. still 2 available
DBG :start another silk (#1) to kill the first one
DBG :dispatching Silk#1
DBG :send msg={code=2, id=1, ctx=(nil)}
DBG :recv msg={code=2, id=1, ctx=(nil)}
DBG :switching from Silk#0 to Silk#1
DBG :switched into Silk#1
INFO:state= 2
INFO:silk 1 starting
DBG :Silk#1 start running - killing Silk#0
DBG :killing Silk#0
DBG :Silk#0 killed by silk thread
DBG :send msg={code=3, id=0, ctx=(nil)}
DBG :Silk#0 killed by Silk#1
INFO:silk 1 ended
DBG :recv msg={code=3, id=0, ctx=(nil)}
DBG :recycling a terminated Silk#0
!!! FIX ME !!! silk initialization code a bit duplicated above (SLIST)
DBG :send msg={code=1, id=0, ctx=(nil)}
DBG :send msg={code=1, id=0, ctx=(nil)}
DBG :recv msg={code=1, id=0, ctx=(nil)}
DBG :switching from Silk#1 to Silk#0
DBG :Silk#0 booting...
DBG :recv msg={code=1, id=0, ctx=(nil)}
DBG :Silk#0 processing BOOT msg
ut_kill__idle_cb
DBG :Silk#1 killed Silk#0
DBG :SHALLOW: top_stack_frame_addr=0xb000ff6c, bottom_stack_frame_addr=0xb000ff38
DBG :stack being used by SHALLOW silk code:0x94 Bytes
DBG :-----------------iteration#5, path=2, depth=1000------------------------
DBG :allocated Silk#0. still 3 available
DBG :dispatching Silk#0
DBG :send msg={code=2, id=0, ctx=(nil)}
DBG :recv msg={code=2, id=0, ctx=(nil)}
INFO:state= 2
INFO:silk 0 starting
DBG :ut_kill__main: Silk#0 starts... (oper=2)
DBG :Doing a 1000 stack recursion ...
DBG :calling yield
ut_kill__idle_cb
DBG :allocated Silk#1. still 2 available
DBG :start another silk (#1) to kill the first one
DBG :dispatching Silk#1
DBG :send msg={code=2, id=1, ctx=(nil)}
DBG :recv msg={code=2, id=1, ctx=(nil)}
DBG :switching from Silk#0 to Silk#1
DBG :switched into Silk#1
INFO:state= 2
INFO:silk 1 starting
DBG :Silk#1 start running - killing Silk#0
DBG :killing Silk#0
DBG :Silk#0 killed by silk thread
DBG :send msg={code=3, id=0, ctx=(nil)}
DBG :Silk#0 killed by Silk#1
INFO:silk 1 ended
DBG :recv msg={code=3, id=0, ctx=(nil)}
DBG :recycling a terminated Silk#0
!!! FIX ME !!! silk initialization code a bit duplicated above (SLIST)
DBG :send msg={code=1, id=0, ctx=(nil)}
DBG :send msg={code=1, id=0, ctx=(nil)}
DBG :recv msg={code=1, id=0, ctx=(nil)}
DBG :switching from Silk#1 to Silk#0
DBG :Silk#0 booting...
DBG :recv msg={code=1, id=0, ctx=(nil)}
DBG :Silk#0 processing BOOT msg
ut_kill__idle_cb
DBG :Silk#1 killed Silk#0
DBG :DEEP: top_stack_frame_addr=0xb000ff6c, bottom_stack_frame_addr=0xb00043e8
DBG :stack being used by DEEP silk code:0xbc18 Bytes
DBG :verifying stack addresses are identical to previous run
DBG :-----------------iteration#5, path=3, depth=1------------------------
DBG :allocated Silk#0. still 3 available
DBG :dispatching Silk#0
DBG :send msg={code=2, id=0, ctx=(nil)}
DBG :recv msg={code=2, id=0, ctx=(nil)}
INFO:state= 2
INFO:silk 0 starting
DBG :ut_kill__main: Silk#0 starts... (oper=2)
DBG :Doing a 1 stack recursion ...
DBG :I'm now waiting for a seconf silk to be dispatched (to issue the killed)
DBG :allocated Silk#1. still 2 available
DBG :start another silk (#1) to kill the first one after it would be killed
DBG :dispatching Silk#1
DBG :send msg={code=2, id=1, ctx=(nil)}
DBG :i'm returning (i.e.: silk terminates naturaly)
DBG :ut_kill__main: Silk#0 ends!!!
INFO:silk 0 ended
DBG :recv msg={code=2, id=1, ctx=(nil)}
DBG :switching from Silk#0 to Silk#1
DBG :switched into Silk#1
INFO:state= 2
INFO:silk 1 starting
DBG :Silk#1 start running - killing Silk#0
DBG :killing Silk#0
DBG :silk 0 is in state 1 - no point killing it.
INFO:silk 1 ended
ut_kill__idle_cb
DBG :SHALLOW: top_stack_frame_addr=0xb000ff6c, bottom_stack_frame_addr=0xb000ff38
DBG :stack being used by SHALLOW silk code:0x94 Bytes
DBG :-----------------iteration#5, path=3, depth=1000------------------------
DBG :allocated Silk#1. still 3 available
DBG :dispatching Silk#1
DBG :send msg={code=2, id=1, ctx=(nil)}
DBG :recv msg={code=2, id=1, ctx=(nil)}
INFO:state= 2
INFO:silk 1 starting
DBG :ut_kill__main: Silk#1 starts... (oper=2)
DBG :Doing a 1000 stack recursion ...
DBG :I'm now waiting for a seconf silk to be dispatched (to issue the killed)
DBG :allocated Silk#0. still 2 available
DBG :start another silk (#0) to kill the first one after it would be killed
DBG :dispatching Silk#0
DBG :send msg={code=2, id=0, ctx=(nil)}
DBG :i'm returning (i.e.: silk terminates naturaly)
DBG :ut_kill__main: Silk#1 ends!!!
INFO:silk 1 ended
DBG :recv msg={code=2, id=0, ctx=(nil)}
DBG :switching from Silk#1 to Silk#0
DBG :switched into Silk#0
INFO:state= 2
INFO:silk 0 starting
DBG :Silk#0 start running - killing Silk#1
DBG :killing Silk#1
DBG :silk 1 is in state 1 - no point killing it.
INFO:silk 0 ended
ut_kill__idle_cb
DBG :DEEP: top_stack_frame_addr=0xb0023f6c, bottom_stack_frame_addr=0xb00183e8
DBG :stack being used by DEEP silk code:0xffff7c18 Bytes
DBG :-----------------iteration#6, path=1, depth=1------------------------
DBG :allocated Silk#0. still 3 available
DBG :dispatching Silk#0
DBG :send msg={code=2, id=0, ctx=(nil)}
DBG :recv msg={code=2, id=0, ctx=(nil)}
INFO:state= 2
INFO:silk 0 starting
DBG :ut_kill__main: Silk#0 starts... (oper=2)
DBG :Doing a 1 stack recursion ...
DBG :silk commits suicide
DBG :killing Silk#0
DBG :Silk#0 killed by silk thread
DBG :Silk#0 killing itself
DBG :send msg={code=3, id=0, ctx=(nil)}
DBG :recv msg={code=3, id=0, ctx=(nil)}
DBG :recycling a terminated Silk#0
!!! FIX ME !!! silk initialization code a bit duplicated above (SLIST)
DBG :send msg={code=1, id=0, ctx=(nil)}
DBG :Silk#0 booting...
DBG :recv msg={code=1, id=0, ctx=(nil)}
DBG :Silk#0 processing BOOT msg
ut_kill__idle_cb
DBG :SHALLOW: top_stack_frame_addr=0xb000ff6c, bottom_stack_frame_addr=0xb000ff38
DBG :stack being used by SHALLOW silk code:0x94 Bytes
DBG :-----------------iteration#6, path=1, depth=1000------------------------
DBG :allocated Silk#0. still 3 available
DBG :dispatching Silk#0
DBG :send msg={code=2, id=0, ctx=(nil)}
DBG :recv msg={code=2, id=0, ctx=(nil)}
INFO:state= 2
INFO:silk 0 starting
DBG :ut_kill__main: Silk#0 starts... (oper=2)
DBG :Doing a 1000 stack recursion ...
DBG :silk commits suicide
DBG :killing Silk#0
DBG :Silk#0 killed by silk thread
DBG :Silk#0 killing itself
DBG :send msg={code=3, id=0, ctx=(nil)}
DBG :recv msg={code=3, id=0, ctx=(nil)}
DBG :recycling a terminated Silk#0
!!! FIX ME !!! silk initialization code a bit duplicated above (SLIST)
DBG :send msg={code=1, id=0, ctx=(nil)}
DBG :Silk#0 booting...
DBG :recv msg={code=1, id=0, ctx=(nil)}
DBG :Silk#0 processing BOOT msg
ut_kill__idle_cb
DBG :DEEP: top_stack_frame_addr=0xb000ff6c, bottom_stack_frame_addr=0xb00043e8
DBG :stack being used by DEEP silk code:0xbc18 Bytes
DBG :verifying stack addresses are identical to previous run
DBG :-----------------iteration#6, path=2, depth=1------------------------
DBG :allocated Silk#0. still 3 available
DBG :dispatching Silk#0
DBG :send msg={code=2, id=0, ctx=(nil)}
DBG :recv msg={code=2, id=0, ctx=(nil)}
INFO:state= 2
INFO:silk 0 starting
DBG :ut_kill__main: Silk#0 starts... (oper=2)
DBG :Doing a 1 stack recursion ...
DBG :calling yield
ut_kill__idle_cb
DBG :allocated Silk#1. still 2 available
DBG :start another silk (#1) to kill the first one
DBG :dispatching Silk#1
DBG :send msg={code=2, id=1, ctx=(nil)}
DBG :recv msg={code=2, id=1, ctx=(nil)}
DBG :switching from Silk#0 to Silk#1
DBG :switched into Silk#1
INFO:state= 2
INFO:silk 1 starting
DBG :Silk#1 start running - killing Silk#0
DBG :killing Silk#0
DBG :Silk#0 killed by silk thread
DBG :send msg={code=3, id=0, ctx=(nil)}
DBG :Silk#0 killed by Silk#1
INFO:silk 1 ended
DBG :recv msg={code=3, id=0, ctx=(nil)}
DBG :recycling a terminated Silk#0
!!! FIX ME !!! silk initialization code a bit duplicated above (SLIST)
DBG :send msg={code=1, id=0, ctx=(nil)}
DBG :send msg={code=1, id=0, ctx=(nil)}
DBG :recv msg={code=1, id=0, ctx=(nil)}
DBG :switching from Silk#1 to Silk#0
DBG :Silk#0 booting...
DBG :recv msg={code=1, id=0, ctx=(nil)}
DBG :Silk#0 processing BOOT msg
ut_kill__idle_cb
DBG :Silk#1 killed Silk#0
DBG :SHALLOW: top_stack_frame_addr=0xb000ff6c, bottom_stack_frame_addr=0xb000ff38
DBG :stack being used by SHALLOW silk code:0x94 Bytes
DBG :-----------------iteration#6, path=2, depth=1000------------------------
DBG :allocated Silk#0. still 3 available
DBG :dispatching Silk#0
DBG :send msg={code=2, id=0, ctx=(nil)}
DBG :recv msg={code=2, id=0, ctx=(nil)}
INFO:state= 2
INFO:silk 0 starting
DBG :ut_kill__main: Silk#0 starts... (oper=2)
DBG :Doing a 1000 stack recursion ...
DBG :calling yield
ut_kill__idle_cb
DBG :allocated Silk#1. still 2 available
DBG :start another silk (#1) to kill the first one
DBG :dispatching Silk#1
DBG :send msg={code=2, id=1, ctx=(nil)}
DBG :recv msg={code=2, id=1, ctx=(nil)}
DBG :switching from Silk#0 to Silk#1
DBG :switched into Silk#1
INFO:state= 2
INFO:silk 1 starting
DBG :Silk#1 start running - killing Silk#0
DBG :killing Silk#0
DBG :Silk#0 killed by silk thread
DBG :send msg={code=3, id=0, ctx=(nil)}
DBG :Silk#0 killed by Silk#1
INFO:silk 1 ended
DBG :recv msg={code=3, id=0, ctx=(nil)}
DBG :recycling a terminated Silk#0
!!! FIX ME !!! silk initialization code a bit duplicated above (SLIST)
DBG :send msg={code=1, id=0, ctx=(nil)}
DBG :send msg={code=1, id=0, ctx=(nil)}
DBG :recv msg={code=1, id=0, ctx=(nil)}
DBG :switching from Silk#1 to Silk#0
DBG :Silk#0 booting...
DBG :recv msg={code=1, id=0, ctx=(nil)}
DBG :Silk#0 processing BOOT msg
ut_kill__idle_cb
DBG :Silk#1 killed Silk#0
DBG :DEEP: top_stack_frame_addr=0xb000ff6c, bottom_stack_frame_addr=0xb00043e8
DBG :stack being used by DEEP silk code:0xbc18 Bytes
DBG :verifying stack addresses are identical to previous run
DBG :-----------------iteration#6, path=3, depth=1------------------------
DBG :allocated Silk#0. still 3 available
DBG :dispatching Silk#0
DBG :send msg={code=2, id=0, ctx=(nil)}
DBG :recv msg={code=2, id=0, ctx=(nil)}
INFO:state= 2
INFO:silk 0 starting
DBG :ut_kill__main: Silk#0 starts... (oper=2)
DBG :Doing a 1 stack recursion ...
DBG :I'm now waiting for a seconf silk to be dispatched (to issue the killed)
DBG :allocated Silk#1. still 2 available
DBG :start another silk (#1) to kill the first one after it would be killed
DBG :dispatching Silk#1
DBG :send msg={code=2, id=1, ctx=(nil)}
DBG :i'm returning (i.e.: silk terminates naturaly)
DBG :ut_kill__main: Silk#0 ends!!!
INFO:silk 0 ended
DBG :recv msg={code=2, id=1, ctx=(nil)}
DBG :switching from Silk#0 to Silk#1
DBG :switched into Silk#1
INFO:state= 2
INFO:silk 1 starting
DBG :Silk#1 start running - killing Silk#0
DBG :killing Silk#0
DBG :silk 0 is in state 1 - no point killing it.
INFO:silk 1 ended
ut_kill__idle_cb
DBG :SHALLOW: top_stack_frame_addr=0xb000ff6c, bottom_stack_frame_addr=0xb000ff38
DBG :stack being used by SHALLOW silk code:0x94 Bytes
DBG :-----------------iteration#6, path=3, depth=1000------------------------
DBG :allocated Silk#1. still 3 available
DBG :dispatching Silk#1
DBG :send msg={code=2, id=1, ctx=(nil)}
DBG :recv msg={code=2, id=1, ctx=(nil)}
INFO:state= 2
INFO:silk 1 starting
DBG :ut_kill__main: Silk#1 starts... (oper=2)
DBG :Doing a 1000 stack recursion ...
DBG :I'm now waiting for a seconf silk to be dispatched (to issue the killed)
DBG :allocated Silk#0. still 2 available
DBG :start another silk (#0) to kill the first one after it would be killed
DBG :dispatching Silk#0
DBG :send msg={code=2, id=0, ctx=(nil)}
DBG :i'm returning (i.e.: silk terminates naturaly)
DBG :ut_kill__main: Silk#1 ends!!!
INFO:silk 1 ended
DBG :recv msg={code=2, id=0, ctx=(nil)}
DBG :switching from Silk#1 to Silk#0
DBG :switched into Silk#0
INFO:state= 2
INFO:silk 0 starting
DBG :Silk#0 start running - killing Silk#1
DBG :killing Silk#1
DBG :silk 1 is in state 1 - no point killing it.
INFO:silk 0 ended
ut_kill__idle_cb
DBG :DEEP: top_stack_frame_addr=0xb0023f6c, bottom_stack_frame_addr=0xb00183e8
DBG :stack being used by DEEP silk code:0xffff7c18 Bytes
DBG :-----------------iteration#7, path=1, depth=1------------------------
DBG :allocated Silk#0. still 3 available
DBG :dispatching Silk#0
DBG :send msg={code=2, id=0, ctx=(nil)}
DBG :recv msg={code=2, id=0, ctx=(nil)}
INFO:state= 2
INFO:silk 0 starting
DBG :ut_kill__main: Silk#0 starts... (oper=2)
DBG :Doing a 1 stack recursion ...
DBG :silk commits suicide
DBG :killing Silk#0
DBG :Silk#0 killed by silk thread
DBG :Silk#0 killing itself
DBG :send msg={code=3, id=0, ctx=(nil)}
DBG :recv msg={code=3, id=0, ctx=(nil)}
DBG :recycling a terminated Silk#0
!!! FIX ME !!! silk initialization code a bit duplicated above (SLIST)
DBG :send msg={code=1, id=0, ctx=(nil)}
DBG :Silk#0 booting...
DBG :recv msg={code=1, id=0, ctx=(nil)}
DBG :Silk#0 processing BOOT msg
ut_kill__idle_cb
DBG :SHALLOW: top_stack_frame_addr=0xb000ff6c, bottom_stack_frame_addr=0xb000ff38
DBG :stack being used by SHALLOW silk code:0x94 Bytes
DBG :-----------------iteration#7, path=1, depth=1000------------------------
DBG :allocated Silk#0. still 3 available
DBG :dispatching Silk#0
DBG :send msg={code=2, id=0, ctx=(nil)}
DBG :recv msg={code=2, id=0, ctx=(nil)}
INFO:state= 2
INFO:silk 0 starting
DBG :ut_kill__main: Silk#0 starts... (oper=2)
DBG :Doing a 1000 stack recursion ...
DBG :silk commits suicide
DBG :killing Silk#0
DBG :Silk#0 killed by silk thread
DBG :Silk#0 killing itself
DBG :send msg={code=3, id=0, ctx=(nil)}
DBG :recv msg={code=3, id=0, ctx=(nil)}
DBG :recycling a terminated Silk#0
!!! FIX ME !!! silk initialization code a bit duplicated above (SLIST)
DBG :send msg={code=1, id=0, ctx=(nil)}
DBG :Silk#0 booting...
DBG :recv msg={code=1, id=0, ctx=(nil)}
DBG :Silk#0 processing BOOT msg
ut_kill__idle_cb
DBG :DEEP: top_stack_frame_addr=0xb000ff6c, bottom_stack_frame_addr=0xb00043e8
DBG :stack being used by DEEP silk code:0xbc18 Bytes
DBG :verifying stack addresses are identical to previous run
DBG :-----------------iteration#7, path=2, depth=1------------------------
DBG :allocated Silk#0. still 3 available
DBG :dispatching Silk#0
DBG :send msg={code=2, id=0, ctx=(nil)}
DBG :recv msg={code=2, id=0, ctx=(nil)}
INFO:state= 2
INFO:silk 0 starting
DBG :ut_kill__main: Silk#0 starts... (oper=2)
DBG :Doing a 1 stack recursion ...
DBG :calling yield
ut_kill__idle_cb
DBG :allocated Silk#1. still 2 available
DBG :start another silk (#1) to kill the first one
DBG :dispatching Silk#1
DBG :send msg={code=2, id=1, ctx=(nil)}
DBG :recv msg={code=2, id=1, ctx=(nil)}
DBG :switching from Silk#0 to Silk#1
DBG :switched into Silk#1
INFO:state= 2
INFO:silk 1 starting
DBG :Silk#1 start running - killing Silk#0
DBG :killing Silk#0
DBG :Silk#0 killed by silk thread
DBG :send msg={code=3, id=0, ctx=(nil)}
DBG :Silk#0 killed by Silk#1
INFO:silk 1 ended
DBG :recv msg={code=3, id=0, ctx=(nil)}
DBG :recycling a terminated Silk#0
!!! FIX ME !!! silk initialization code a bit duplicated above (SLIST)
DBG :send msg={code=1, id=0, ctx=(nil)}
DBG :send msg={code=1, id=0, ctx=(nil)}
DBG :recv msg={code=1, id=0, ctx=(nil)}
DBG :switching from Silk#1 to Silk#0
DBG :Silk#0 booting...
DBG :recv msg={code=1, id=0, ctx=(nil)}
DBG :Silk#0 processing BOOT msg
ut_kill__idle_cb
DBG :Silk#1 killed Silk#0
DBG :SHALLOW: top_stack_frame_addr=0xb000ff6c, bottom_stack_frame_addr=0xb000ff38
DBG :stack being used by SHALLOW silk code:0x94 Bytes
DBG :-----------------iteration#7, path=2, depth=1000------------------------
DBG :allocated Silk#0. still 3 available
DBG :dispatching Silk#0
DBG :send msg={code=2, id=0, ctx=(nil)}
DBG :recv msg={code=2, id=0, ctx=(nil)}
INFO:state= 2
INFO:silk 0 starting
DBG :ut_kill__main: Silk#0 starts... (oper=2)
DBG :Doing a 1000 stack recursion ...
DBG :calling yield
ut_kill__idle_cb
DBG :allocated Silk#1. still 2 available
DBG :start another silk (#1) to kill the first one
DBG :dispatching Silk#1
DBG :send msg={code=2, id=1, ctx=(nil)}
DBG :recv msg={code=2, id=1, ctx=(nil)}
DBG :switching from Silk#0 to Silk#1
DBG :switched into Silk#1
INFO:state= 2
INFO:silk 1 starting
DBG :Silk#1 start running - killing Silk#0
DBG :killing Silk#0
DBG :Silk#0 killed by silk thread
DBG :send msg={code=3, id=0, ctx=(nil)}
DBG :Silk#0 killed by Silk#1
INFO:silk 1 ended
DBG :recv msg={code=3, id=0, ctx=(nil)}
DBG :recycling a terminated Silk#0
!!! FIX ME !!! silk initialization code a bit duplicated above (SLIST)
DBG :send msg={code=1, id=0, ctx=(nil)}
DBG :send msg={code=1, id=0, ctx=(nil)}
DBG :recv msg={code=1, id=0, ctx=(nil)}
DBG :switching from Silk#1 to Silk#0
DBG :Silk#0 booting...
DBG :recv msg={code=1, id=0, ctx=(nil)}
DBG :Silk#0 processing BOOT msg
ut_kill__idle_cb
DBG :Silk#1 killed Silk#0
DBG :DEEP: top_stack_frame_addr=0xb000ff6c, bottom_stack_frame_addr=0xb00043e8
DBG :stack being used by DEEP silk code:0xbc18 Bytes
DBG :verifying stack addresses are identical to previous run
DBG :-----------------iteration#7, path=3, depth=1------------------------
DBG :allocated Silk#0. still 3 available
DBG :dispatching Silk#0
DBG :send msg={code=2, id=0, ctx=(nil)}
DBG :recv msg={code=2, id=0, ctx=(nil)}
INFO:state= 2
INFO:silk 0 starting
DBG :ut_kill__main: Silk#0 starts... (oper=2)
DBG :Doing a 1 stack recursion ...
DBG :I'm now waiting for a seconf silk to be dispatched (to issue the killed)
DBG :allocated Silk#1. still 2 available
DBG :start another silk (#1) to kill the first one after it would be killed
DBG :dispatching Silk#1
DBG :send msg={code=2, id=1, ctx=(nil)}
DBG :i'm returning (i.e.: silk terminates naturaly)
DBG :ut_kill__main: Silk#0 ends!!!
INFO:silk 0 ended
DBG :recv msg={code=2, id=1, ctx=(nil)}
DBG :switching from Silk#0 to Silk#1
DBG :switched into Silk#1
INFO:state= 2
INFO:silk 1 starting
DBG :Silk#1 start running - killing Silk#0
DBG :killing Silk#0
DBG :silk 0 is in state 1 - no point killing it.
INFO:silk 1 ended
ut_kill__idle_cb
DBG :SHALLOW: top_stack_frame_addr=0xb000ff6c, bottom_stack_frame_addr=0xb000ff38
DBG :stack being used by SHALLOW silk code:0x94 Bytes
DBG :-----------------iteration#7, path=3, depth=1000------------------------
DBG :allocated Silk#1. still 3 available
DBG :dispatching Silk#1
DBG :send msg={code=2, id=1, ctx=(nil)}
DBG :recv msg={code=2, id=1, ctx=(nil)}
INFO:state= 2
INFO:silk 1 starting
DBG :ut_kill__main: Silk#1 starts... (oper=2)
DBG :Doing a 1000 stack recursion ...
DBG :I'm now waiting for a seconf silk to be dispatched (to issue the killed)
DBG :allocated Silk#0. still 2 available
DBG :start another silk (#0) to kill the first one after it would be killed
DBG :dispatching Silk#0
DBG :send msg={code=2, id=0, ctx=(nil)}
DBG :i'm returning (i.e.: silk terminates naturaly)
DBG :ut_kill__main: Silk#1 ends!!!
INFO:silk 1 ended
DBG :recv msg={code=2, id=0, ctx=(nil)}
DBG :switching from Silk#1 to Silk#0
DBG :switched into Silk#0
INFO:state= 2
INFO:silk 0 starting
DBG :Silk#0 start running - killing Silk#1
DBG :killing Silk#1
DBG :silk 1 is in state 1 - no point killing it.
INFO:silk 0 ended
ut_kill__idle_cb
DBG :DEEP: top_stack_frame_addr=0xb0023f6c, bottom_stack_frame_addr=0xb00183e8
DBG :stack being used by DEEP silk code:0xffff7c18 Bytes
DBG :-----------------iteration#8, path=1, depth=1------------------------
DBG :allocated Silk#0. still 3 available
DBG :dispatching Silk#0
DBG :send msg={code=2, id=0, ctx=(nil)}
DBG :recv msg={code=2, id=0, ctx=(nil)}
INFO:state= 2
INFO:silk 0 starting
DBG :ut_kill__main: Silk#0 starts... (oper=2)
DBG :Doing a 1 stack recursion ...
DBG :silk commits suicide
DBG :killing Silk#0
DBG :Silk#0 killed by silk thread
DBG :Silk#0 killing itself
DBG :send msg={code=3, id=0, ctx=(nil)}
DBG :recv msg={code=3, id=0, ctx=(nil)}
DBG :recycling a terminated Silk#0
!!! FIX ME !!! silk initialization code a bit duplicated above (SLIST)
DBG :send msg={code=1, id=0, ctx=(nil)}
DBG :Silk#0 booting...
DBG :recv msg={code=1, id=0, ctx=(nil)}
DBG :Silk#0 processing BOOT msg
ut_kill__idle_cb
DBG :SHALLOW: top_stack_frame_addr=0xb000ff6c, bottom_stack_frame_addr=0xb000ff38
DBG :stack being used by SHALLOW silk code:0x94 Bytes
DBG :-----------------iteration#8, path=1, depth=1000------------------------
DBG :allocated Silk#0. still 3 available
DBG :dispatching Silk#0
DBG :send msg={code=2, id=0, ctx=(nil)}
DBG :recv msg={code=2, id=0, ctx=(nil)}
INFO:state= 2
INFO:silk 0 starting
DBG :ut_kill__main: Silk#0 starts... (oper=2)
DBG :Doing a 1000 stack recursion ...
DBG :silk commits suicide
DBG :killing Silk#0
DBG :Silk#0 killed by silk thread
DBG :Silk#0 killing itself
DBG :send msg={code=3, id=0, ctx=(nil)}
DBG :recv msg={code=3, id=0, ctx=(nil)}
DBG :recycling a terminated Silk#0
!!! FIX ME !!! silk initialization code a bit duplicated above (SLIST)
DBG :send msg={code=1, id=0, ctx=(nil)}
DBG :Silk#0 booting...
DBG :recv msg={code=1, id=0, ctx=(nil)}
DBG :Silk#0 processing BOOT msg
ut_kill__idle_cb
DBG :DEEP: top_stack_frame_addr=0xb000ff6c, bottom_stack_frame_addr=0xb00043e8
DBG :stack being used by DEEP silk code:0xbc18 Bytes
DBG :verifying stack addresses are identical to previous run
DBG :-----------------iteration#8, path=2, depth=1------------------------
DBG :allocated Silk#0. still 3 available
DBG :dispatching Silk#0
DBG :send msg={code=2, id=0, ctx=(nil)}
DBG :recv msg={code=2, id=0, ctx=(nil)}
INFO:state= 2
INFO:silk 0 starting
DBG :ut_kill__main: Silk#0 starts... (oper=2)
DBG :Doing a 1 stack recursion ...
DBG :calling yield
ut_kill__idle_cb
DBG :allocated Silk#1. still 2 available
DBG :start another silk (#1) to kill the first one
DBG :dispatching Silk#1
DBG :send msg={code=2, id=1, ctx=(nil)}
DBG :recv msg={code=2, id=1, ctx=(nil)}
DBG :switching from Silk#0 to Silk#1
DBG :switched into Silk#1
INFO:state= 2
INFO:silk 1 starting
DBG :Silk#1 start running - killing Silk#0
DBG :killing Silk#0
DBG :Silk#0 killed by silk thread
DBG :send msg={code=3, id=0, ctx=(nil)}
DBG :Silk#0 killed by Silk#1
INFO:silk 1 ended
DBG :recv msg={code=3, id=0, ctx=(nil)}
DBG :recycling a terminated Silk#0
!!! FIX ME !!! silk initialization code a bit duplicated above (SLIST)
DBG :send msg={code=1, id=0, ctx=(nil)}
DBG :send msg={code=1, id=0, ctx=(nil)}
DBG :recv msg={code=1, id=0, ctx=(nil)}
DBG :switching from Silk#1 to Silk#0
DBG :Silk#0 booting...
DBG :recv msg={code=1, id=0, ctx=(nil)}
DBG :Silk#0 processing BOOT msg
ut_kill__idle_cb
DBG :Silk#1 killed Silk#0
DBG :SHALLOW: top_stack_frame_addr=0xb000ff6c, bottom_stack_frame_addr=0xb000ff38
DBG :stack being used by SHALLOW silk code:0x94 Bytes
DBG :-----------------iteration#8, path=2, depth=1000------------------------
DBG :allocated Silk#0. still 3 available
DBG :dispatching Silk#0
DBG :send msg={code=2, id=0, ctx=(nil)}
DBG :recv msg={code=2, id=0, ctx=(nil)}
INFO:state= 2
INFO:silk 0 starting
DBG :ut_kill__main: Silk#0 starts... (oper=2)
DBG :Doing a 1000 stack recursion ...
DBG :calling yield
ut_kill__idle_cb
DBG :allocated Silk#1. still 2 available
DBG :start another silk (#1) to kill the first one
DBG :dispatching Silk#1
DBG :send msg={code=2, id=1, ctx=(nil)}
DBG :recv msg={code=2, id=1, ctx=(nil)}
DBG :switching from Silk#0 to Silk#1
DBG :switched into Silk#1
INFO:state= 2
INFO:silk 1 starting
DBG :Silk#1 start running - killing Silk#0
DBG :killing Silk#0
DBG :Silk#0 killed by silk thread
DBG :send msg={code=3, id=0, ctx=(nil)}
DBG :Silk#0 killed by Silk#1
INFO:silk 1 ended
DBG :recv msg={code=3, id=0, ctx=(nil)}
DBG :recycling a terminated Silk#0
!!! FIX ME !!! silk initialization code a bit duplicated above (SLIST)
DBG :send msg={code=1, id=0, ctx=(nil)}
DBG :send msg={code=1, id=0, ctx=(nil)}
DBG :recv msg={code=1, id=0, ctx=(nil)}
DBG :switching from Silk#1 to Silk#0
DBG :Silk#0 booting...
DBG :recv msg={code=1, id=0, ctx=(nil)}
DBG :Silk#0 processing BOOT msg
ut_kill__idle_cb
DBG :Silk#1 killed Silk#0
DBG :DEEP: top_stack_frame_addr=0xb000ff6c, bottom_stack_frame_addr=0xb00043e8
DBG :stack being used by DEEP silk code:0xbc18 Bytes
DBG :verifying stack addresses are identical to previous run
DBG :-----------------iteration#8, path=3, depth=1------------------------
DBG :allocated Silk#0. still 3 available
DBG :dispatching Silk#0
DBG :send msg={code=2, id=0, ctx=(nil)}
DBG :recv msg={code=2, id=0, ctx=(nil)}
INFO:state= 2
INFO:silk 0 starting
DBG :ut_kill__main: Silk#0 starts... (oper=2)
DBG :Doing a 1 stack recursion ...
DBG :I'm now waiting for a seconf silk to be dispatched (to issue the killed)
DBG :allocated Silk#1. still 2 available
DBG :start another silk (#1) to kill the first one after it would be killed
DBG :dispatching Silk#1
DBG :send msg={code=2, id=1, ctx=(nil)}
DBG :i'm returning (i.e.: silk terminates naturaly)
DBG :ut_kill__main: Silk#0 ends!!!
INFO:silk 0 ended
DBG :recv msg={code=2, id=1, ctx=(nil)}
DBG :switching from Silk#0 to Silk#1
DBG :switched into Silk#1
INFO:state= 2
INFO:silk 1 starting
DBG :Silk#1 start running - killing Silk#0
DBG :killing Silk#0
DBG :silk 0 is in state 1 - no point killing it.
INFO:silk 1 ended
ut_kill__idle_cb
DBG :SHALLOW: top_stack_frame_addr=0xb000ff6c, bottom_stack_frame_addr=0xb000ff38
DBG :stack being used by SHALLOW silk code:0x94 Bytes
DBG :-----------------iteration#8, path=3, depth=1000------------------------
DBG :allocated Silk#1. still 3 available
DBG :dispatching Silk#1
DBG :send msg={code=2, id=1, ctx=(nil)}
DBG :recv msg={code=2, id=1, ctx=(nil)}
INFO:state= 2
INFO:silk 1 starting
DBG :ut_kill__main: Silk#1 starts... (oper=2)
DBG :Doing a 1000 stack recursion ...
DBG :I'm now waiting for a seconf silk to be dispatched (to issue the killed)
DBG :allocated Silk#0. still 2 available
DBG :start another silk (#0) to kill the first one after it would be killed
DBG :dispatching Silk#0
DBG :send msg={code=2, id=0, ctx=(nil)}
DBG :i'm returning (i.e.: silk terminates naturaly)
DBG :ut_kill__main: Silk#1 ends!!!
INFO:silk 1 ended
DBG :recv msg={code=2, id=0, ctx=(nil)}
DBG :switching from Silk#1 to Silk#0
DBG :switched into Silk#0
INFO:state= 2
INFO:silk 0 starting
DBG :Silk#0 start running - killing Silk#1
DBG :killing Silk#1
DBG :silk 1 is in state 1 - no point killing it.
INFO:silk 0 ended
ut_kill__idle_cb
DBG :DEEP: top_stack_frame_addr=0xb0023f6c, bottom_stack_frame_addr=0xb00183e8
DBG :stack being used by DEEP silk code:0xffff7c18 Bytes
DBG :-----------------iteration#9, path=1, depth=1------------------------
DBG :allocated Silk#0. still 3 available
DBG :dispatching Silk#0
DBG :send msg={code=2, id=0, ctx=(nil)}
DBG :recv msg={code=2, id=0, ctx=(nil)}
INFO:state= 2
INFO:silk 0 starting
DBG :ut_kill__main: Silk#0 starts... (oper=2)
DBG :Doing a 1 stack recursion ...
DBG :silk commits suicide
DBG :killing Silk#0
DBG :Silk#0 killed by silk thread
DBG :Silk#0 killing itself
DBG :send msg={code=3, id=0, ctx=(nil)}
DBG :recv msg={code=3, id=0, ctx=(nil)}
DBG :recycling a terminated Silk#0
!!! FIX ME !!! silk initialization code a bit duplicated above (SLIST)
DBG :send msg={code=1, id=0, ctx=(nil)}
DBG :Silk#0 booting...
DBG :recv msg={code=1, id=0, ctx=(nil)}
DBG :Silk#0 processing BOOT msg
ut_kill__idle_cb
DBG :SHALLOW: top_stack_frame_addr=0xb000ff6c, bottom_stack_frame_addr=0xb000ff38
DBG :stack being used by SHALLOW silk code:0x94 Bytes
DBG :-----------------iteration#9, path=1, depth=1000------------------------
DBG :allocated Silk#0. still 3 available
DBG :dispatching Silk#0
DBG :send msg={code=2, id=0, ctx=(nil)}
DBG :recv msg={code=2, id=0, ctx=(nil)}
INFO:state= 2
INFO:silk 0 starting
DBG :ut_kill__main: Silk#0 starts... (oper=2)
DBG :Doing a 1000 stack recursion ...
DBG :silk commits suicide
DBG :killing Silk#0
DBG :Silk#0 killed by silk thread
DBG :Silk#0 killing itself
DBG :send msg={code=3, id=0, ctx=(nil)}
DBG :recv msg={code=3, id=0, ctx=(nil)}
DBG :recycling a terminated Silk#0
!!! FIX ME !!! silk initialization code a bit duplicated above (SLIST)
DBG :send msg={code=1, id=0, ctx=(nil)}
DBG :Silk#0 booting...
DBG :recv msg={code=1, id=0, ctx=(nil)}
DBG :Silk#0 processing BOOT msg
ut_kill__idle_cb
DBG :DEEP: top_stack_frame_addr=0xb000ff6c, bottom_stack_frame_addr=0xb00043e8
DBG :stack being used by DEEP silk code:0xbc18 Bytes
DBG :verifying stack addresses are identical to previous run
DBG :-----------------iteration#9, path=2, depth=1------------------------
DBG :allocated Silk#0. still 3 available
DBG :dispatching Silk#0
DBG :send msg={code=2, id=0, ctx=(nil)}
DBG :recv msg={code=2, id=0, ctx=(nil)}
INFO:state= 2
INFO:silk 0 starting
DBG :ut_kill__main: Silk#0 starts... (oper=2)
DBG :Doing a 1 stack recursion ...
DBG :calling yield
ut_kill__idle_cb
DBG :allocated Silk#1. still 2 available
DBG :start another silk (#1) to kill the first one
DBG :dispatching Silk#1
DBG :send msg={code=2, id=1, ctx=(nil)}
DBG :recv msg={code=2, id=1, ctx=(nil)}
DBG :switching from Silk#0 to Silk#1
DBG :switched into Silk#1
INFO:state= 2
INFO:silk 1 starting
DBG :Silk#1 start running - killing Silk#0
DBG :killing Silk#0
DBG :Silk#0 killed by silk thread
DBG :send msg={code=3, id=0, ctx=(nil)}
DBG :Silk#0 killed by Silk#1
INFO:silk 1 ended
DBG :recv msg={code=3, id=0, ctx=(nil)}
DBG :recycling a terminated Silk#0
!!! FIX ME !!! silk initialization code a bit duplicated above (SLIST)
DBG :send msg={code=1, id=0, ctx=(nil)}
DBG :send msg={code=1, id=0, ctx=(nil)}
DBG :recv msg={code=1, id=0, ctx=(nil)}
DBG :switching from Silk#1 to Silk#0
DBG :Silk#0 booting...
DBG :recv msg={code=1, id=0, ctx=(nil)}
DBG :Silk#0 processing BOOT msg
ut_kill__idle_cb
DBG :Silk#1 killed Silk#0
DBG :SHALLOW: top_stack_frame_addr=0xb000ff6c, bottom_stack_frame_addr=0xb000ff38
DBG :stack being used by SHALLOW silk code:0x94 Bytes
DBG :-----------------iteration#9, path=2, depth=1000------------------------
DBG :allocated Silk#0. still 3 available
DBG :dispatching Silk#0
DBG :send msg={code=2, id=0, ctx=(nil)}
DBG :recv msg={code=2, id=0, ctx=(nil)}
INFO:state= 2
INFO:silk 0 starting
DBG :ut_kill__main: Silk#0 starts... (oper=2)
DBG :Doing a 1000 stack recursion ...
DBG :calling yield
ut_kill__idle_cb
DBG :allocated Silk#1. still 2 available
DBG :start another silk (#1) to kill the first one
DBG :dispatching Silk#1
DBG :send msg={code=2, id=1, ctx=(nil)}
DBG :recv msg={code=2, id=1, ctx=(nil)}
DBG :switching from Silk#0 to Silk#1
DBG :switched into Silk#1
INFO:state= 2
INFO:silk 1 starting
DBG :Silk#1 start running - killing Silk#0
DBG :killing Silk#0
DBG :Silk#0 killed by silk thread
DBG :send msg={code=3, id=0, ctx=(nil)}
DBG :Silk#0 killed by Silk#1
INFO:silk 1 ended
DBG :recv msg={code=3, id=0, ctx=(nil)}
DBG :recycling a terminated Silk#0
!!! FIX ME !!! silk initialization code a bit duplicated above (SLIST)
DBG :send msg={code=1, id=0, ctx=(nil)}
DBG :send msg={code=1, id=0, ctx=(nil)}
DBG :recv msg={code=1, id=0, ctx=(nil)}
DBG :switching from Silk#1 to Silk#0
DBG :Silk#0 booting...
DBG :recv msg={code=1, id=0, ctx=(nil)}
DBG :Silk#0 processing BOOT msg
ut_kill__idle_cb
DBG :Silk#1 killed Silk#0
DBG :DEEP: top_stack_frame_addr=0xb000ff6c, bottom_stack_frame_addr=0xb00043e8
DBG :stack being used by DEEP silk code:0xbc18 Bytes
DBG :verifying stack addresses are identical to previous run
DBG :-----------------iteration#9, path=3, depth=1------------------------
DBG :allocated Silk#0. still 3 available
DBG :dispatching Silk#0
DBG :send msg={code=2, id=0, ctx=(nil)}
DBG :recv msg={code=2, id=0, ctx=(nil)}
INFO:state= 2
INFO:silk 0 starting
DBG :ut_kill__main: Silk#0 starts... (oper=2)
DBG :Doing a 1 stack recursion ...
DBG :I'm now waiting for a seconf silk to be dispatched (to issue the killed)
DBG :allocated Silk#1. still 2 available
DBG :start another silk (#1) to kill the first one after it would be killed
DBG :dispatching Silk#1
DBG :send msg={code=2, id=1, ctx=(nil)}
DBG :i'm returning (i.e.: silk terminates naturaly)
DBG :ut_kill__main: Silk#0 ends!!!
INFO:silk 0 ended
DBG :recv msg={code=2, id=1, ctx=(nil)}
DBG :switching from Silk#0 to Silk#1
DBG :switched into Silk#1
INFO:state= 2
INFO:silk 1 starting
DBG :Silk#1 start running - killing Silk#0
DBG :killing Silk#0
DBG :silk 0 is in state 1 - no point killing it.
INFO:silk 1 ended
ut_kill__idle_cb
DBG :SHALLOW: top_stack_frame_addr=0xb000ff6c, bottom_stack_frame_addr=0xb000ff38
DBG :stack being used by SHALLOW silk code:0x94 Bytes
DBG :-----------------iteration#9, path=3, depth=1000------------------------
DBG :allocated Silk#1. still 3 available
DBG :dispatching Silk#1
DBG :send msg={code=2, id=1, ctx=(nil)}
DBG :recv msg={code=2, id=1, ctx=(nil)}
INFO:state= 2
INFO:silk 1 starting
DBG :ut_kill__main: Silk#1 starts... (oper=2)
DBG :Doing a 1000 stack recursion ...
DBG :I'm now waiting for a seconf silk to be dispatched (to issue the killed)
DBG :allocated Silk#0. still 2 available
DBG :start another silk (#0) to kill the first one after it would be killed
DBG :dispatching Silk#0
DBG :send msg={code=2, id=0, ctx=(nil)}
DBG :i'm returning (i.e.: silk terminates naturaly)
DBG :ut_kill__main: Silk#1 ends!!!
INFO:silk 1 ended
DBG :recv msg={code=2, id=0, ctx=(nil)}
DBG :switching from Silk#1 to Silk#0
DBG :switched into Silk#0
INFO:state= 2
INFO:silk 0 starting
DBG :Silk#0 start running - killing Silk#1
DBG :killing Silk#1
DBG :silk 1 is in state 1 - no point killing it.
INFO:silk 0 ended
ut_kill__idle_cb
DBG :DEEP: top_stack_frame_addr=0xb0023f6c, bottom_stack_frame_addr=0xb00183e8
DBG :stack being used by DEEP silk code:0xffff7c18 Bytes
DBG :send msg={code=4, id=0, ctx=(nil)}
DBG :Silk termination returns:0
DBG :recv msg={code=4, id=0, ctx=(nil)}
INFO:kernel thread 3078269760 processing TERM msg
INFO:thread 3078269760 switching back to pthread stack
INFO:Thread exiting. id=3078269760
DBG :Silk join returns:0
